<?php declare(strict_types = 1);

namespace Happysir\Lock;

use Happysir\Lock\Contract\LockInterface;
use Swoft\Bean\Annotation\Mapping\Bean;
use Swoft\Bean\Annotation\Mapping\Primary;
use Swoft\Co;
use Swoft\Log\Helper\CLog;
use Swoft\Redis\Connection\Connection;
use Swoft\Redis\Redis;
use Swoole\Coroutine;
use Throwable;
use function swoole_random_int;

/**
 * Class RedisLock
 * @Bean(scope=Bean::PROTOTYPE)
 * @Primary()
 */
class RedisLock implements LockInterface
{
    /**
     * the lock key
     *
     * @var string
     */
    private $key;
    
    /**
     * the unique id generated by the current co
     *
     * @var string
     */
    protected $value;
    
    /**
     * the lock key's life time
     *
     * @var int
     */
    private $ttl;
    
    /**
     * get lock，This method will return fasle directly after the lock is failed.
     *
     * @param string $key lock unique identifier
     * @param int    $ttl
     *
     * @return bool
     * @throws \Throwable
     */
    public function tryLock(string $key, int $ttl = 3) : bool
    {
        return $this->doLock($key, $ttl);
    }
    
    /**
     * get lock，This method will return fasle directly after the lock is failed.
     *
     * @param string $key     lock unique identifier
     * @param int    $ttl
     * @param int    $retries number of retries
     *
     * @return bool
     * @throws \Throwable
     */
    public function lock(string $key, int $ttl = 3, int $retries = 3) : bool
    {
        $times = 0;
        
        while ($times < $retries) {
            
            if ($this->doLock($key, $ttl)) {
                return true;
            }
            
            Coroutine::sleep(0.5);
            
            $times++;
            
            CLog::debug('Try to acquire the lock again, the number of attempts: %d', $times);
        }
        
        return false;
    }
    
    /**
     * Let the lock last for N seconds, the default N is 3
     *
     * @param int $ttl
     *
     * @return bool
     * @throws \Throwable
     */
    public function keepAlive(int $ttl = 3) : bool
    {
        $lua = <<<LUA
                -- get the remaining life time of the key
                local leftoverTtl = redis.call("TTL", KEYS[1]);
                
                -- never expired key
                if (leftoverTtl == -1) then
                    return -1;
                end;
                
                -- key with remaining time
                if (leftoverTtl ~= -2) then
                    return redis.call("EXPIRE", KEYS[1], ARGV[1]);
                end;
                
                -- key that does not exist
                return -2;
LUA;
        
        try {
            $eval = $this->getConnection()->eval($lua, [$this->key, $ttl], 1);
            
            return $eval !== -2;
        } catch (Throwable $e) {
            CLog::error($e->getMessage());
            throw $e;
        }
    }
    
    /**
     * check if the lock is valid
     *
     * @return bool
     * @throws \Throwable
     */
    public function isAlive() : bool
    {
        if (!$this->key) {
            return false;
        }
        
        try {
            $eval = $this->getConnection()->get($this->key);
            
            return $eval === $this->value;
        } catch (Throwable $e) {
            CLog::error($e->getMessage());
            throw $e;
        }
    }
    
    /**
     * release lock
     *
     * @return bool
     * @throws \Throwable
     */
    public function unLock() : bool
    {
        $lua = <<<LUA
                local hashVal = redis.call("GET", KEYS[1]);
                if (hashVal ~=  ARGV[1]) then
                    return hashVal;
                end;
                
                return redis.call("DEL", KEYS[1]);
LUA;
        
        try {
            $eval = $this->getConnection()->eval($lua, [$this->key, $this->value], 1);
            
            if ($eval) {
                CLog::debug(
                    'worker[%s] co[%s]successful release unlock',
                    server()->getSwooleServer()->worker_id,
                    Co::tid()
                );
            }
            
            return (bool) $eval;
        } catch (Throwable $e) {
            CLog::error($e->getMessage());
            throw $e;
        }
    }
    
    /**
     * get redis connection
     *
     * @return \Swoft\Redis\Connection\Connection
     * @throws \Swoft\Redis\Exception\RedisException
     */
    protected function getConnection() : Connection
    {
        return Redis::connection();
    }
    
    /**
     * get lock
     *
     * @param string $key
     * @param int    $ttl
     *
     * @return bool
     * @throws \Throwable
     */
    protected function doLock(string $key, int $ttl = 3) : bool
    {
        /** @var \Happysir\Lock\Contract\UuidIterface $uuidManage */
        $uuidManage = bean('uuidManage');
        
        $this->key   = $key;
        $flag        = (string)swoole_random_int(1, 10000000000);
        $this->value = $uuidManage->generate($flag);
        $this->ttl   = $ttl;
        
        try {
            $parameters = [$this->key, $this->value, ['nx', 'ex' => $ttl]];
            $result     = (bool)$this->getConnection()->command('set', $parameters);
            
            if ($result) {
                CLog::debug(
                    'worker[%s] co[%s] successfully hold lock[uuid:%s], initialize the watchdog task',
                    server()->getSwooleServer()->worker_id,
                    Co::tid()
                );
                
                Co::create(
                    function () {
                        /** @var \Happysir\Lock\Contract\WatchDogInterface $watchDogTask */
                        $watchDogTask = bean('watchDog');
                        
                        $watchDogTask->sentinel($this);
                    }, false
                );
            }
            
            return (bool) $result;
        } catch (Throwable $e) {
            CLog::error($e->getMessage());
            throw $e;
        }
    }
    
    /**
     * get lock life ttl
     *
     * @return int
     */
    public function lockTtl() : int
    {
        return $this->ttl;
    }
}
